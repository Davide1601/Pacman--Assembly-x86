TITLE Pacman 2.0, Chris Cullati Bryan Quinlan, November 5, 2013				(main.asm)

; 
; 
; 
; 
; Revision date:

INCLUDE Irvine32.inc
INCLUDE mCheckRow.txt

.data

champ_x	BYTE 23						;Pacman's x coordinate on the console
champ_xnew BYTE 23					;when a direction is pressed, champ_xnew holds the x coordinate pacman is trying to enter
champ_y BYTE 14						;Pacman's y coordinate
champ_ynew BYTE 14					;Champ_xnew : x coordinate :: champ_ynew : y coordinate (thats an analogy)
champ BYTE '<'						;Represents pacman (initially facing right)
char BYTE ?							;A placeholder variable
lives BYTE 3						;Represents Pacman's remaining lives
powermode BYTE 0					;Boolean, 1 means powermode on, 0 means off
powercount BYTE 0					;How many updates left until powermode ends
POWER_MAX db 100					;Max powermode time, decreases as level increases
dots BYTE 0							;How many dots pacman has eaten this level, bonus fruit is dependent on this
level db 1							;Represents what Level you are on
bonus dw 0							;how much the bonus is worth
hasbonuslife db 0					;boolean for having bonus life or not

pauseme db 0						;Basically a boolean, 1 means game is paused, 0 means game is unpaused
pausescreen_msg BYTE "**PAUSED**", 0

score WORD 0						;Player's score
scoreMod WORD 100					;The number by which score is incremented
score_msg BYTE "Score: ",0			;Message for outputting score
level_msg BYTE "Level: ",0
lives_msg BYTE "Lives: ",0			;I'd like to implement this differently, with the lives indicatd by little pacmen at the bottom, but for now this works

mapwdots0 BYTE	"############################",0
mapwdots1 BYTE	"#............##............#", 0
mapwdots2 BYTE	"#.####.#####.##.#####.####.#", 0
mapwdots3 BYTE	"#*#  #.#   #.##.#   #.#  #*#", 0
mapwdots4 BYTE	"#.####.#####.##.#####.####.#", 0
mapwdots5 BYTE	"#..........................#", 0
mapwdots6 BYTE	"#.####.##.########.##.####.#", 0
mapwdots7 BYTE	"#.####.##.########.##.####.#", 0
mapwdots8 BYTE	"#......##....##....##......#", 0
mapwdots9 BYTE	"######.##### ## #####.######", 0
mapwdots10 BYTE	"     #.##### ## #####.#     ", 0
mapwdots11 BYTE	"     #.##    @     ##.#     ", 0
mapwdots12 BYTE	"     #.## ###--### ##.#     ", 0
mapwdots13 BYTE	"######.## #      # ##.######", 0
mapwdots14 BYTE	"      .   # @ @ @#   .      ", 0
mapwdots15 BYTE	"######.## #      # ##.######", 0
mapwdots16 BYTE	"     #.## ######## ##.#     ", 0
mapwdots17 BYTE	"     #.##          ##.#     ", 0
mapwdots18 BYTE	"     #.## ######## ##.#     ", 0
mapwdots19 BYTE	"######.## ######## ##.######", 0
mapwdots20 BYTE	"#............##............#", 0
mapwdots21 BYTE	"#.####.#####.##.#####.####.#", 0
mapwdots22 BYTE	"#.####.#####.##.#####.####.#", 0
mapwdots23 BYTE	"#*..##........ .......##..*#", 0
mapwdots24 BYTE	"###.##.##.########.##.##.###", 0
mapwdots25 BYTE	"###.##.##.########.##.##.###", 0
mapwdots26 BYTE	"#......##....##....##......#", 0
mapwdots27 BYTE	"#.##########.##.##########.#", 0
mapwdots28 BYTE	"#.##########.##.##########.#", 0
mapwdots29 BYTE "#..........................#", 0
mapwdots30 BYTE	"############################", 0


.code

main PROC
	Update:
		call UpdateChamp					;Update function, checks keys and alters rest of program appropriately
		cmp champ_X, -1						;Check if q was pressed (quits if so)
		je exitron
		cmp pauseme, 1						;check if p was pressed (pauses if so)
		je paused
		call CheckMove						;runs proc to see if new move generated by UpdateChamp is legal, allows if legal, disallows if illegal
		call PrintMapWithDots				;prints the map
		call WriteChamp						;prints Pacman
		call CheckDots						;checks stuff related to score and drawing of bonus fruit
		mov dh, 0
		mov dl, 31
		call GoToXY
		mov edx, OFFSET level_msg			;level output on the side of the game
		call WriteString
		mov al, level
		call WriteDec
		mov dh, 1
		mov dl, 31
		call GoToXY
		mov edx, OFFSET lives_msg			;lives output on side
		call WriteString
		mov al, lives
		call WriteDec
		mov dh, 2
		mov dl, 31
		call GoToXY
		mov edx, OFFSET score_msg			;score output on side
		call WriteString
		mov ax, score
		call WriteDec
		call CheckScore						;checks to see whether or not bonus life should be added
		mov al, champ_x						;super important
		mov bl, champ_y						;Sets champ_x/ynew
		mov champ_xnew, al					;to champ_x/y
		mov champ_ynew, bl					;without this, one could keep pressing left against a wall until new_y = a legal value then pac would teleport there
		mov eax, 200						;after testing, delay of 200 seems to work best with regards to screen flicker and FPS
		call Delay
		call Clrscr							;clear the screen and update, I will test this later to see if it is even necessary (I think it will be)
		jmp Update							;infinite loop unless quit or pause (really just quit)

	paused:									;jumps here when paused to loop until unpaused
		call UpdatePause					;check basically just to see if pause has been pressed again
		call PauseScreen					;display pause screen
		cmp pauseme, 0						;check pause value
		
		je Update
		jne paused
	exitron:								;end of program. This is where we will implement game over screens, highscores, and any other extras. also additional levels
		exit

main ENDP

PrintMapWithDots PROC

mov dl, 0
mov dh, 0
call GoToXY

mov edx, OFFSET mapwdots0
call WriteString
call Crlf
mov edx, OFFSET mapwdots1
call WriteString
call Crlf
mov edx, OFFSET mapwdots2
call WriteString
call Crlf
mov edx, OFFSET mapwdots3
call WriteString
call Crlf
mov edx, OFFSET mapwdots4
call WriteString
call Crlf
mov edx, OFFSET mapwdots5
call WriteString
call Crlf
mov edx, OFFSET mapwdots6
call WriteString
call Crlf
mov edx, OFFSET mapwdots7
call WriteString
call Crlf
mov edx, OFFSET mapwdots8
call WriteString
call Crlf
mov edx, OFFSET mapwdots9
call WriteString
call Crlf
mov edx, OFFSET mapwdots10
call WriteString
call Crlf
mov edx, OFFSET mapwdots11
call WriteString
call Crlf
mov edx, OFFSET mapwdots12
call WriteString
call Crlf
mov edx, OFFSET mapwdots13
call WriteString
call Crlf
mov edx, OFFSET mapwdots14
call WriteString
call Crlf
mov edx, OFFSET mapwdots15
call WriteString
call Crlf
mov edx, OFFSET mapwdots16
call WriteString
call Crlf
mov edx, OFFSET mapwdots17
call WriteString
call Crlf
mov edx, OFFSET mapwdots18
call WriteString
call Crlf
mov edx, OFFSET mapwdots19
call WriteString
call Crlf
mov edx, OFFSET mapwdots20
call WriteString
call Crlf
mov edx, OFFSET mapwdots21
call WriteString
call Crlf
mov edx, OFFSET mapwdots22
call WriteString
call Crlf
mov edx, OFFSET mapwdots23
call WriteString
call Crlf
mov edx, OFFSET mapwdots24
call WriteString
call Crlf
mov edx, OFFSET mapwdots25
call WriteString
call Crlf
mov edx, OFFSET mapwdots26
call WriteString
call Crlf
mov edx, OFFSET mapwdots27
call WriteString
call Crlf
mov edx, OFFSET mapwdots28
call WriteString
call Crlf
mov edx, OFFSET mapwdots29
call WriteString
call Crlf
mov edx, OFFSET mapwdots30
call WriteString
call Crlf

RET
PrintMapWithDots ENDP

UpdateChamp PROC
	call ReadKey			;readkey is in the irvine32 library and it performs a no-wait check to the state of the keyboard-
							; -and returns the ascii value of the key to ax, as well as the scancode to dx and one other, idk its in the book and I didn't use it
	jz skip					;Also it returns zero if there is no key pressed so just skip and rewrite the map/champ
	mov char, al


	;Quit (Q or q)
	cmp char, 81
	je quit_pressed
	cmp char, 113
	je quit_pressed

	;Pause (P or p)
	cmp char, 80
	je pause_pressed
	cmp char, 112
	je pause_pressed
	
	;left (A or a)
	cmp char, 97
	je left_pressed
	cmp char, 65
	je left_pressed

	;right (D or d)
	cmp char, 68
	je right_pressed
	cmp char, 100
	je right_pressed

	;up (W or w)
	cmp char, 87
	je up_pressed
	cmp char, 119
	je up_pressed

	;down (S or s)
	cmp char, 83
	je down_pressed
	cmp char, 115
	je down_pressed

	jmp skip

	left_pressed:
		dec champ_ynew
		mov champ, '>'						;changes pacman's "sprite" if he changes direction
		jmp skip
	right_pressed:
		inc champ_ynew
		mov champ, '<'
		jmp skip
	up_pressed:
		dec champ_xnew
		mov champ, 'v'
		jmp skip
	down_pressed:
		inc champ_xnew
		mov champ, '^'
		jmp skip
	quit_pressed:
		mov champ_x, -1
		jmp skip
	pause_pressed:
		cmp pauseme, 0
		je pauseit
		jne unpauseit
		pauseit:
			mov pauseme, 1
			jmp skip
		unpauseit:
			mov pauseme, 0
			jmp skip

	skip:
		ret
UpdateChamp ENDP

UpdatePause PROC
	call ReadKey
	mov char, al
	
	;Pause (P or p)
	cmp char, 80
	je Pause_pressed
	cmp char, 112
	je Pause_pressed
	
	jmp Skip

	Pause_pressed:
		cmp pauseme, 0
		je PauseIt
		jne UnpauseIt
		PauseIt:
			mov pauseme, 1
			jmp Skip
		UnpauseIt:
			mov pauseme, 0
			jmp Skip
	Skip:

	ret
UpdatePause ENDP

WriteChamp PROC
	AND eax, 0
	AND edx, 0
	mov dh, champ_x
	mov dl, champ_y
	call GoToXY
	mov al, champ
	call WriteChar
	ret
WriteChamp ENDP

WheresChamp PROC				;Debug method, maybe re-enabled in Durga mode or something. Displays coordinates of pac as well as x/ynew in top left
	mov dx, 0
	call GoToXY
	AND eax, 0
	mov al, champ_x
	call WriteInt
	call CRLF
	mov al, champ_y
	call WriteInt
	call CRLF
	AND eax, 0
	mov al, champ_xnew
	call WriteInt
	call CRLF
	AND eax, 0
	mov al, champ_ynew
	call WriteInt
	call CRLF
	ret
WheresChamp ENDP

CheckMove PROC
	;check move happens between UpdateChamp and WriteChamp to see if pacman should be written to the new location or not.

	;I used a macro that accepts champ_y and the appropriate string to check (mapwdotsX, 0 <= X <= 30) that tests [mapwdotsX+champ_ynew] to see what character is there
	;more on that at implementation
	
	cmp champ_xnew, -1				;disallow negative values for champ_x
	jle skip
	cmp champ_ynew, -1				;if ynew is -1, test for special case tunnel on left
	jz testxleft
	cmp champ_xnew, 31				;champ_x cannot exceed 29
	jge skip
	cmp champ_ynew, 28				;if ynew is 28, test for special case tunnel on right
	jz testxright
	jg skip

	cmp champ_xnew, 10				;checks champ_xnew against 10 to jump over some checks to speed things up
	ja oneThird
	cmp champ_xnew, 20				;checks again to potentially skip 10 more checks
	ja twoThirds

	cmp champ_xnew, 0				;Big section of cmp-jcond pairs that tell the program what row pacman is in
	jz Row0
	cmp champ_xnew, 1
	jz Row1
	cmp champ_xnew, 2
	jz Row2
	cmp champ_xnew, 3
	jz Row3
	cmp champ_xnew, 4
	jz Row4
	cmp champ_xnew, 5
	jz Row5
	cmp champ_xnew, 6
	jz Row6
	cmp champ_xnew, 7
	jz Row7
	cmp champ_xnew, 8
	jz Row8
	cmp champ_xnew, 9
	jz Row9
	cmp champ_xnew, 10
	jz Row10
oneThird:
	cmp champ_xnew, 11
	jz Row11
	cmp champ_xnew, 12
	jz Row12
	cmp champ_xnew, 13
	jz Row13
	cmp champ_xnew, 14
	jz Row14
	cmp champ_xnew, 15
	jz Row15
	cmp champ_xnew, 16
	jz Row16
	cmp champ_xnew, 17
	jz Row17
	cmp champ_xnew, 18
	jz Row18
	cmp champ_xnew, 19
	jz Row19
	cmp champ_xnew, 20
	jz Row20
twoThirds:
	cmp champ_xnew, 21
	jz Row21
	cmp champ_xnew, 22
	jz Row22
	cmp champ_xnew, 23
	jz Row23
	cmp champ_xnew, 24
	jz Row24
	cmp champ_xnew, 25
	jz Row25
	cmp champ_xnew, 26
	jz Row26
	cmp champ_xnew, 27
	jz Row27
	cmp champ_xnew, 28
	jz Row28
	cmp champ_xnew, 29
	jz Row29
	cmp champ_xnew, 30
	jz Row30

;contents of mCheckrow:
	;the macro works by pasting the following code into the program in place of the line "mCheckrow champ_ynew, mapwdotsX, qX"

;mCheckrow MACRO champ_ynew, rowtocheck, loopname
	;mov esi, OFFSET rowtocheck				;;rowtocheck is replaced with "mapwdotsX"
	;inc champ_ynew							;;couldn't do "mov ecx, champ_ynew+1" so this was the next best thing
	;mov ecx, champ_ynew					;;this loops through the loop (champ_ynew+1) times, in order to get the value from esi for appropriate location
	;loopname:								;;loopname exists so that there is no overloading of the same label (because a macro is basically a big TEXTEQU)
	;	mov al, [esi]						;;get character from esi into al
	;	inc esi
	;LOOP loopname
	;dec champ_ynew							;;so as not to mess with actual move
	;cmp al, '#'							;;Walls are #
	;jz isWall
	;cmp al, '-'							;;Ghost-pen walls are walls too
	;jz isWall
	;cmp al, '.'							;;A period represents a pellet to eat for points
	;jz isPellet
	;cmp al, '*'							;;An asterisk represents a power pellet
	;jz isPowerPellet
	;cmp al, '@'							;;An @ represents a ghost. 2spooky4me
	;jz isGhost
	;cmp al, '%'							;;A % represents a bonus fruit
	;jz isBonus
	;jmp isntWall
;ENDM
	
	Row0:
		mCheckRow champ_ynew, mapwdots0, q0
	Row1:
		mCheckRow champ_ynew, mapwdots1, q1
	Row2:
		mCheckRow champ_ynew, mapwdots2, q2
	Row3:
		mCheckRow champ_ynew, mapwdots3, q3
	Row4:
		mCheckRow champ_ynew, mapwdots4, q4
	Row5:
		mCheckRow champ_ynew, mapwdots5, q5
	Row6:
		mCheckRow champ_ynew, mapwdots6, q6
	Row7:
		mCheckRow champ_ynew, mapwdots7, q7
	Row8:
		mCheckRow champ_ynew, mapwdots8, q8
	Row9:
		mCheckRow champ_ynew, mapwdots9, q9
	Row10:
		mCheckRow champ_ynew, mapwdots10, q10
	Row11:
		mCheckRow champ_ynew, mapwdots11, q11
	Row12:
		mCheckRow champ_ynew, mapwdots12, q12
	Row13:
		mCheckRow champ_ynew, mapwdots13, q13
	Row14:
		mCheckRow champ_ynew, mapwdots14, q14
	Row15:
		mCheckRow champ_ynew, mapwdots15, q15
	Row16:
		mCheckRow champ_ynew, mapwdots16, q16
	Row17:
		mCheckRow champ_ynew, mapwdots17, q17
	Row18:
		mCheckRow champ_ynew, mapwdots18, q18
	Row19:
		mCheckRow champ_ynew, mapwdots19, q19
	Row20:
		mCheckRow champ_ynew, mapwdots20, q20
	Row21:
		mCheckRow champ_ynew, mapwdots21, q21
	Row22:
		mCheckRow champ_ynew, mapwdots22, q22
	Row23:
		mCheckRow champ_ynew, mapwdots23, q23
	Row24:
		mCheckRow champ_ynew, mapwdots24, q24
	Row25:
		mCheckRow champ_ynew, mapwdots25, q25
	Row26:
		mCheckRow champ_ynew, mapwdots26, q26
	Row27:
		mCheckRow champ_ynew, mapwdots27, q27
	Row28:
		mCheckRow champ_ynew, mapwdots28, q28
	Row29:
		mCheckRow champ_ynew, mapwdots29, q29
	Row30:
		mCheckRow champ_ynew, mapwdots30, q30

	testxright:								;tests for special case tunnel on right side
		cmp champ_xnew, 14
		jnz skip
		mov champ_y, 0						;send pac to opposite side if in appropriate row
		jmp skip

	testxleft:								;tests for special case tunnel on left side
		cmp champ_xnew, 14
		jnz skip
		mov champ_y, 27						;send pac to opposite side again
		jmp skip

	isWall:									;these labels all catch jumps that come from mCheckRow
		jmp skip							;If a wall, then just skip and exit without changing champ_x/y

	isntWall:
		mov al, champ_xnew					;if not a wall, move is legal and thus champ_x = champ_xnew, champ_y = champ_ynew
		mov bl, champ_ynew
		mov champ_x, al
		mov champ_y, bl
		jmp skip

	isPellet:								;if pellet, then move is legal, x/y updated, '.' removed from string for that row, and score updated appropriately
		mov cl, ' '
		mov [esi-1], cl
		mov al, champ_xnew
		mov bl, champ_ynew
		mov champ_x, al
		mov champ_y, bl
		mov cx, scoreMod
		add score, cx
		inc dots
		jmp skip

	isPowerPellet:							;if Power Pellet, then move is legal, x/y updated, * replaced with ' ' in appropriate row.
		mov cl, ' '
		mov [esi-1], cl
		add score, 50
		mov al, champ_xnew
		mov bl, champ_ynew
		mov champ_x, al
		mov champ_y, bl
		cmp powermode, 0
		jz powerOn
		jnz powerAlreadyOn

		powerOn:
			mov powermode, 1
			mov bl, POWER_MAX
			mov powercount, bl
		powerAlreadyOn:
			mov bl, POWER_MAX
			mov powercount, bl
		jmp skip

	isGhost:
		;implement pacman death, lives--, score-something, and reset position after death screen
		;also potentially implement ghost eating cmp powermode, 1 jz killghost jnz killthepacman
		cmp powermode, 0
		jz killthepacman
		jnz killghost

		killthepacman:
			dec lives						;minus 1 life for dying obv
			mov champ_x, 23					;reset to starting position
			mov champ_y, 14
		jmp skip

		killghost:
			mov cl, ' '
			mov [esi-1], cl
			mov al, champ_xnew
			mov bl, champ_ynew
			mov champ_x, al
			mov champ_y, bl
			;This part is where Nick comes in
		jmp skip
	isBonus:
		mov cl, ' '
		mov [esi-1], cl
		mov al, champ_xnew
		mov bl, champ_ynew
		mov champ_x, al
		mov champ_y, bl
		mov dx, bonus
		add score, dx
		jmp skip

	skip: ret
CheckMove ENDP

PauseScreen PROC
	mov dh, 14
	mov dl, 7
	call GOTOXY
	mov edx, OFFSET pausescreen_msg
	call WriteString
	ret
PauseScreen ENDP

CheckDots PROC
	cmp dots, 70
	jz spawnbonus
	cmp dots, 170
	jz spawnbonus
	
	jmp skip

	spawnbonus:
		mov cl, '%'
		cmp level, 1
		jz level1
		cmp level, 2
		jz level2
		cmp level, 3
		jz level3
		
		level1:
			mov [mapwdots11+14], cl
			mov bonus, 100
			jmp skip
		level2:
			mov [mapwdots11+14], cl
			mov bonus, 300
			jmp skip
		level3:
			mov [mapwdots11+14], cl
			mov bonus, 500
			jmp skip
	skip:
	ret
CheckDots ENDP

CheckScore PROC
	cmp score, 10000
	jge bonuslife
	jmp hasit

	bonuslife:
		cmp hasbonuslife, 1
		jz hasit
		inc lives
		mov hasbonuslife, 1
	hasit:
	ret
CheckScore ENDP


END main